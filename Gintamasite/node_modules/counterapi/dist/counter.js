'use strict';

var axios = require('axios');

/**
 * API Configuration
 */
const API_CONFIG = {
    v1: {
        baseUrl: 'https://api.counterapi.dev/v1',
        endpoints: {
            up: '/{namespace}/{name}/up',
            down: '/{namespace}/{name}/down',
            get: '/{namespace}/{name}',
            set: '/{namespace}/{name}/?count={value}',
        },
    },
    v2: {
        baseUrl: 'https://api.counterapi.dev/v2',
        endpoints: {
            up: '/{workspace}/{name}/up',
            down: '/{workspace}/{name}/down',
            get: '/{workspace}/{name}',
            reset: '/{workspace}/{name}/reset',
            stats: '/{workspace}/{name}/stats',
        },
    },
};
/**
 * Axios-based HTTP client implementation
 */
class AxiosHttpClient {
    constructor(config) {
        this.version = config.version;
        this.accessToken = config.accessToken;
        this.client = axios.create({
            baseURL: API_CONFIG[this.version].baseUrl,
            timeout: config.timeout || 10000,
            headers: {
                'Content-Type': 'application/json',
                ...(config.accessToken && { 'Authorization': `Bearer ${config.accessToken}` })
            }
        });
        // Request interceptor for debugging
        if (config.debug) {
            this.client.interceptors.request.use((request) => {
                console.log('[CounterAPI] Request:', {
                    method: request.method?.toUpperCase(),
                    url: request.url,
                    headers: request.headers,
                    data: request.data
                });
                return request;
            });
        }
        // Response interceptor for debugging and error handling
        this.client.interceptors.response.use((response) => {
            if (config.debug) {
                console.log('[CounterAPI] Response:', {
                    status: response.status,
                    data: response.data
                });
            }
            return response;
        }, (error) => {
            if (config.debug) {
                console.log('[CounterAPI] Error:', {
                    status: error.response?.status,
                    data: error.response?.data,
                    message: error.message
                });
            }
            // Transform axios error to our custom error format
            const apiError = {
                message: error.response?.data?.message || error.message || 'Request failed',
                status: error.response?.status,
                code: error.response?.data?.code || error.code,
                details: error.response?.data
            };
            throw apiError;
        });
    }
    /**
     * Creates a URL by replacing placeholders in the endpoint pattern
     */
    createUrl(endpoint, params) {
        let url = endpoint;
        // Replace named parameters in URL pattern
        for (const [key, value] of Object.entries(params)) {
            url = url.replace(`{${key}}`, String(value));
        }
        return url;
    }
    async get(url, config) {
        const response = await this.client.get(url, config);
        return response.data;
    }
    async post(url, data, config) {
        const response = await this.client.post(url, data, config);
        return response.data;
    }
}

/**
 * Main Counter client class
 */
class Counter {
    constructor(config) {
        this.version = config.version || 'v2'; // Default to v2 if not specified
        // Handle namespace/workspace parameter based on version
        if (this.version === 'v2') {
            // For v2, prefer workspace parameter if provided, otherwise fall back to namespace
            this.namespace = config.workspace || config.namespace || '';
        }
        else {
            // For v1, use namespace parameter
            this.namespace = config.namespace || '';
        }
        // Validate required config
        if (!this.namespace) {
            if (this.version === 'v2') {
                throw new Error('Workspace is required for v2 API');
            }
            else {
                throw new Error('Namespace is required for v1 API');
            }
        }
        // Initialize HTTP client
        this.http = new AxiosHttpClient({
            version: this.version,
            timeout: config.timeout,
            debug: config.debug,
            accessToken: config.accessToken
        });
    }
    /**
     * Get the current counter value
     * @param name - The counter name
     * @returns Promise resolving to counter response
     */
    async get(name) {
        if (!name) {
            throw new Error('Counter name is required');
        }
        const endpoint = this.createEndpointUrl('get', { name });
        return await this.http.get(endpoint);
    }
    /**
     * Increment the counter value by 1
     * @param name - The counter name
     * @returns Promise resolving to counter response
     */
    async up(name) {
        if (!name) {
            throw new Error('Counter name is required');
        }
        const endpoint = this.createEndpointUrl('up', { name });
        return await this.http.get(endpoint);
    }
    /**
     * Decrement the counter value by 1
     * @param name - The counter name
     * @returns Promise resolving to counter response
     */
    async down(name) {
        if (!name) {
            throw new Error('Counter name is required');
        }
        const endpoint = this.createEndpointUrl('down', { name });
        return await this.http.get(endpoint);
    }
    /**
     * Set the counter value (v1 only)
     * @param name - The counter name
     * @param value - The value to set
     * @returns Promise resolving to counter response
     */
    async set(name, value) {
        if (this.version !== 'v1') {
            throw new Error('set method is only available in v1');
        }
        if (!name) {
            throw new Error('Counter name is required');
        }
        const endpoint = this.createEndpointUrl('set', { name, value });
        return await this.http.get(endpoint);
    }
    /**
     * Reset the counter value to 0 (v2 only)
     * @param name - The counter name
     * @returns Promise resolving to counter response
     */
    async reset(name) {
        if (this.version !== 'v2') {
            throw new Error('reset method is only available in v2');
        }
        if (!name) {
            throw new Error('Counter name is required');
        }
        const endpoint = this.createEndpointUrl('reset', { name });
        return await this.http.get(endpoint);
    }
    /**
     * Get counter statistics (v2 only)
     * @param name - The counter name
     * @returns Promise resolving to counter stats response
     */
    async stats(name) {
        if (this.version !== 'v2') {
            throw new Error('stats method is only available in v2');
        }
        if (!name) {
            throw new Error('Counter name is required');
        }
        const endpoint = this.createEndpointUrl('stats', { name });
        return await this.http.get(endpoint);
    }
    /**
     * Creates a URL by replacing placeholders in the endpoint pattern
     */
    createEndpointUrl(method, params) {
        // Get the endpoint pattern based on version and method
        const endpoints = API_CONFIG[this.version].endpoints;
        let endpointPattern;
        if (this.version === 'v1') {
            const v1Endpoints = endpoints;
            endpointPattern = v1Endpoints[method];
        }
        else {
            const v2Endpoints = endpoints;
            endpointPattern = v2Endpoints[method];
        }
        if (!endpointPattern) {
            throw new Error(`Invalid method: ${method}`);
        }
        // Replace namespace/workspace placeholder based on version
        const namespaceKey = this.version === 'v1' ? 'namespace' : 'workspace';
        // Prepare params for URL creation
        const urlParams = {
            [namespaceKey]: this.namespace,
            ...params
        };
        // In axios HTTP client, create the URL by replacing placeholders
        return this.http.createUrl(endpointPattern, urlParams);
    }
}
// Backward compatibility alias
const CounterClient = Counter;

exports.Counter = Counter;
exports.CounterClient = CounterClient;
//# sourceMappingURL=counter.js.map
